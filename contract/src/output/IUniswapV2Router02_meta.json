{"compiler":{"version":"0.8.19+commit.7dd6d404"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"}],"name":"getAmountsOut","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForTokens","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"}],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"compilationTarget":{"/src/XRPMPT.sol":"IUniswapV2Router02"},"evmVersion":"london","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"/src/XRPMPT.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Interface for UniSwap Router to interact with UniSwap V2 for token swaps.\ninterface IUniswapV2Router02 {\n    // Get the amount of tokens out for a given input amount.\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n    // Execute a token swap from one token to another.\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n}\n\n// ERC20 Token interface to allow interaction with tokens (transfer, transferFrom, approve).\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract XRPMPT {\n    // UniSwap Router for token swaps.\n    IUniswapV2Router02 public uniswapRouter;\n\n    // Uniswap V2 Router address.\n    address public uniswapRouterAddress = 0xeE567Fe1712Faf6149d80dA1E6934E354124CfE3;\n\n    // wethToken address.\n    address public wethToken = 0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9;\n    // rlusdToken address.\n    address public rlusdToken = 0xe101FB315a64cDa9944E570a7bFfaFE60b994b1D;\n\n    // Array to hold the addresses of the 2 assets.\n    address[] public assets = [\n        0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984,  // UNI\n        0x779877A7B0D9E8603169DdbD7836e478b4624789   // LINK\n    ];\n\n    // Mapping to track the amount of each asset held by a user.\n    // userAssets[address][assetIndex] = amount\n    mapping(address => uint[2]) public userAssets;\n\n    // Mapping to track the deposited balance of each user.\n    mapping(address => uint256) public balances;\n\n    // Array to store the allocation percentages for each of the 2 assets.\n    uint[2] public weights;\n\n    // Constructor initializes the contract with the rlusd token address, UniSwap router, and the asset token addresses.\n    constructor() {\n        // Assign UniSwap router address.\n        uniswapRouter = IUniswapV2Router02(uniswapRouterAddress);\n    }\n\n    // Function to set the weights for the 2 assets.\n    // Weights should sum up to 100%.\n    function setWeights(uint[2] calldata _weights) external {\n        uint totalWeight = 0;\n        // Calculate total weight to ensure it's 100%.\n        for (uint i = 0; i < _weights.length; i++) {\n            totalWeight += _weights[i];\n        }\n        // Check that total weight is 100%.\n        require(totalWeight == 100, \"Total weight must sum to 100%\");\n        // Set the weights for the 2 assets.\n        weights = _weights;\n    }\n\n    // Deposit function that allows a user to deposit rlusd and convert it into the 2 assets based on the set weights.\n    function deposit(uint _rlusdAmount) external {\n        // Transfer rlusd tokens from the user to the contract.\n        require(IERC20(rlusdToken).transferFrom(msg.sender, address(this), _rlusdAmount), \"Transfer failed\");\n        // Update the user's deposit balance.\n        balances[msg.sender] += _rlusdAmount;\n    }\n\n    function deposit_rlusd(uint _rlusdAmount) external {\n         // Transfer rlusd tokens from the sender to the contract.\n         require(IERC20(rlusdToken).transferFrom(msg.sender, address(this), _rlusdAmount), \"Transfer failed\");\n\n         // Loop through each asset and perform the conversion.\n         for (uint i = 0; i < assets.length; i++) {\n             // Calculate how much of each asset the user will receive.\n             uint assetAmount = (_rlusdAmount * weights[i]) / 100;\n             // Convert rlusd to the specific asset.\n             _convertRlusdToAsset(assetAmount, assets[i]);\n             // Update the user's asset balance.\n             userAssets[msg.sender][i] += assetAmount;\n         }\n    }\n\n    // Helper function to perform the conversion of rlusd to the specified asset using UniSwap.\n    function _convertRlusdToAsset(uint _amountIn, address _assetOut) internal {\n        // Define the token conversion path (rlusd -> weth -> asset).\n        address[] memory path = new address[](3);\n        path[0] = rlusdToken;\n        path[1] = wethToken;\n        path[2] = _assetOut;\n\n        // Get the minimum amount of the output token we will receive based on current UniSwap rates.\n        uint[] memory amountsOut = uniswapRouter.getAmountsOut(_amountIn, path);\n        uint amountOutMin = amountsOut[1]; // This is the minimum amount of the asset we should receive.\n\n        // Approve UniSwap to spend the rlusd tokens on behalf of the contract.\n        IERC20(rlusdToken).approve(address(uniswapRouter), _amountIn);\n\n        // Execute the token swap on UniSwap\n        uniswapRouter.swapExactTokensForTokens(_amountIn, amountOutMin, path, address(this), block.timestamp);\n    }\n\n    // Withdraw function allows a user to withdraw their assets, converting them back to rlusd.\n    function withdraw(uint256 _amount) external {\n        // Check that the user has enough balance to withdraw.\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n\n        // Update the user's deposit balance.\n        balances[msg.sender] -= _amount;\n\n        // Transfer the rlusd tokens from the contract back to the user.\n        require(IERC20(rlusdToken).transfer(msg.sender, _amount), \"Transfer failed\");\n    }\n\n     function withdraw_rlusd(uint[2] calldata _amounts) external {\n         uint rlusdAmount = 0;\n         // Loop through each asset and convert the specified amounts back to rlusd.\n         for (uint i = 0; i < _amounts.length; i++) {\n             if(userAssets[msg.sender][i] >= 0) {\n                 uint assetAmount = _amounts[i];\n                 userAssets[msg.sender][i] -= assetAmount; // Update user's asset balance by subtracting the withdrawn amount.\n\n                 // Convert the asset to rlusd.\n                 uint amountOut = _convertAssetToRlusd(assetAmount, assets[i]);\n                 // Add the value to the total rlusd amount.\n                 rlusdAmount += amountOut;\n             }\n         }\n         // Transfer the accumulated rlusd back to the user.\n         require(IERC20(rlusdToken).transfer(msg.sender, rlusdAmount), \"Transfer failed\");\n     }\n\n    // Helper function to convert a specific asset back into rlusd using UniSwap.\n    function _convertAssetToRlusd(uint _amountIn, address _assetIn) internal returns (uint) {\n        // Define the token conversion path (rlusd -> weth -> asset).\n        address[] memory path = new address[](3);\n        path[0] = _assetIn;\n        path[1] = wethToken;\n        path[2] = rlusdToken;\n\n        // Get the minimum amount of rlusd we will receive based on current UniSwap rates.\n        uint[] memory amountsOut = uniswapRouter.getAmountsOut(_amountIn, path);\n        // This is the minimum amount of rlusd we should receive\n        uint amountOutMin = amountsOut[1];\n\n        // Approve UniSwap to spend the asset on behalf of the contract.\n        IERC20(_assetIn).approve(address(uniswapRouter), _amountIn);\n\n        // Execute the token swap on UniSwap.\n        uniswapRouter.swapExactTokensForTokens(_amountIn, amountOutMin, path, address(this), block.timestamp);\n\n        // Return the amount of rlusd received.\n        return amountOutMin;\n    }\n\n    // Function to get the total value of the user's portfolio in rlusd.\n    // It sums the value of each asset the user holds.\n    function getValue(address _user) external view returns (uint totalValue) {\n        totalValue = 0;\n        // Loop through each asset and calculate the total value in rlusd.\n        for (uint i = 0; i < assets.length; i++) {\n            uint assetAmount = userAssets[_user][i];\n            // Add the value of each asset to the total.\n            totalValue += _getAssetValueInRlusd(assetAmount, assets[i]);\n        }\n    }\n\n    // Helper function to get the value of a single asset in rlusd using UniSwap.\n    function _getAssetValueInRlusd(uint _amountIn, address _asset) internal view returns (uint) {\n        // Define the token conversion path (rlusd -> weth -> asset).\n        address[] memory path = new address[](3);\n        path[0] = _asset;\n        path[1] = wethToken;\n        path[2] = rlusdToken;\n\n        // Get the output amount of rlusd for the given input amount of the asset.\n        uint[] memory amountsOut = uniswapRouter.getAmountsOut(_amountIn, path);\n        return amountsOut[1]; // Return the estimated amount of rlusd.\n    }\n\n    // Function to get the amount of each asset the user holds.\n    function getAssets(address _user) external view returns (uint[2] memory) {\n        // Return the array of asset holdings for the user.\n        return userAssets[_user];\n    }\n}","keccak256":"0x88d5ed737466524da22286310d08396846be0a76273040704960dfb4f4f8d01d","license":"MIT"}},"version":1}